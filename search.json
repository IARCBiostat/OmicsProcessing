[{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/data-filtering.html","id":"modular-workflow","dir":"Articles","previous_headings":"","what":"Modular Workflow","title":"Data filtering with filter_by_missingness()","text":"following example illustrates custom pipeline using individual functions package. section accompanied explanation guidance. detailed parameter descriptions, please refer function documentation (e.g., ?OmicsProcessing::filter_by_missingness). modular approach particularly useful users need detailed control processing steps want adapt parts pipeline specific datasets experimental designs. full argument details, see function reference: filter_by_missingness().","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/data-filtering.html","id":"step-1-filter-by-missingness","dir":"Articles","previous_headings":"Modular Workflow","what":"Step 1: Filter by missingness","title":"Data filtering with filter_by_missingness()","text":"step removes features /samples high proportion missing values. can customise thresholds specify samples Quality Control (QC). QC rows always retained returned dataset, excluded calculating missingness proportions. can either pass regular expression automatic feature column detection (example target_cols = \"@\" function classify columns @ feature column).","code":"filtered_df <- OmicsProcessing::filter_by_missingness(   df,   row_thresh = 0.5,  # Remove features with >50% missingness   col_thresh = 0.5,  # Remove samples with >50% missingness   target_cols = \"@\",  # Automatically detect feature columns   is_qc = grepl(\"^sQC\", df$sample_type),  # Identify QC samples   filter_order = \"iterative\"  # Default: iterative filtering )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/data-filtering.html","id":"filtering-order-filter_order","dir":"Articles","previous_headings":"Modular Workflow > Step 1: Filter by missingness","what":"Filtering order (filter_order)","title":"Data filtering with filter_by_missingness()","text":"parameter filter_order controls sequence row column filtering applied: \"iterative\" (default): Alternates row column filtering results stop changing (max_iter reached). Ensures row column thresholds satisfied simultaneously. \"col_then_row\": Removes columns first, filters rows. \"row_then_col\": Removes rows first, filters columns. \"simultaneous\": Determines rows columns keep independently, intersects results. \"iterative\" option generally conservative: repeatedly refines dataset row column criteria satisfied, can produce different results compared one-pass methods.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/data-filtering.html","id":"example","dir":"Articles","previous_headings":"Modular Workflow > Step 1: Filter by missingness","what":"Example","title":"Data filtering with filter_by_missingness()","text":"dataset (rows 2 5 marked QC): Different filter_order choices yield different results: Notice row 1 retained iterative case dropped simultaneous case, iterative procedure keeps alternating row column criteria satisfied together.","code":"df <- data.frame(   a = c(NA, 1, NA, 1, NA),   b = c(NA, NA, 2, 2, NA),   c = c(3, NA, NA, 3, NA),   d = 1 ) is_qc <- c(FALSE, TRUE, FALSE, FALSE, TRUE) target_cols <- c(\"a\",\"b\",\"c\")  df #    a  b  c d # 1 NA NA  3 1 # 2  1 NA NA 1   <- QC # 3 NA  2 NA 1 # 4  1  2  3 1 # 5 NA NA NA 1   <- QC # Iterative (default) filter_by_missingness(df, 0.5, 0.5, target_cols, is_qc, filter_order = \"iterative\") #    b  c d # 1 NA  3 1 # 2 NA NA 1 # 3  2 NA 1 # 4  2  3 1 # 5 NA NA 1  # Simultaneous filter_by_missingness(df, 0.5, 0.5, target_cols, is_qc, filter_order = \"simultaneous\") #    b  c d # 2 NA NA 1 # 4  2  3 1 # 5 NA NA 1"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/developer-guidelines.html","id":"welcome","dir":"Articles","previous_headings":"","what":"Welcome","title":"Developers & Contributors","text":"welcome contributions OmicsProcessing! highest priority clean code good documentation — emphasis good.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/developer-guidelines.html","id":"how-to-contribute","dir":"Articles","previous_headings":"Welcome","what":"How to Contribute","title":"Developers & Contributors","text":"Fork repository. Create new issue describing objective planned change. Develop changes separate branch. finished, open pull request review. pull requests must pass unit tests (UTs) include clear documentation.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/developer-guidelines.html","id":"coding-style-guidelines","dir":"Articles","previous_headings":"Welcome","what":"Coding Style Guidelines","title":"Developers & Contributors","text":"Modular design: factor task function. Naming: lowercase, snake_case, meaningfully descriptive. Documentation: every function must complete roxygen2 docs, including least one example. LLM-assisted cleanup: feel free use LLMs improve clarity, formatting, naming suggestions.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/developer-guidelines.html","id":"example-function-with-roxygen2-documentation","dir":"Articles","previous_headings":"Welcome > Coding Style Guidelines","what":"Example function with roxygen2 documentation","title":"Developers & Contributors","text":"Note @export Functions marked @export available end users. Functions without @export remain internal helpers—can still tested documented, part public API.","code":"#' Add Two Numbers #' #' This function takes two numeric values and returns their sum. #' #' @param x A numeric value. #' @param y A numeric value. #' #' @return A numeric value representing the sum of `x` and `y`. #' @export #' #' @examples #' add_two_numbers(1, 2) #' add_two_numbers(-5, 10) add_two_numbers <- function(x, y) {   x + y }"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/developer-guidelines.html","id":"unit-tests-uts","dir":"Articles","previous_headings":"Welcome","what":"Unit Tests (UTs)","title":"Developers & Contributors","text":"Every function must accompanying unit tests. Unit tests check function behavior guide future contributors changes needed.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/developer-guidelines.html","id":"example-unit-test","dir":"Articles","previous_headings":"Welcome > Unit Tests (UTs)","what":"Example unit test","title":"Developers & Contributors","text":"","code":"test_that(\"add_two_numbers works as expected\", {   expect_equal(add_two_numbers(1, 2), 3)   expect_equal(add_two_numbers(-5, 10), 5)   expect_true(is.numeric(add_two_numbers(2, 2))) })"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/developer-guidelines.html","id":"writing-good-uts-mini-guide","dir":"Articles","previous_headings":"Welcome","what":"Writing Good UTs (mini-guide)","title":"Developers & Contributors","text":"Good tests verify behavior (public API contracts), implementation details. Aim small, fast, deterministic tests. cover Happy path: typical, correct usage. Edge cases: empty inputs, single row/column, NA/NaN/Inf, duplicated IDs, extreme values. Bad inputs: wrong types/shapes; assert errors informative messages. Boundaries: --one, min/max thresholds, zero/negative values. Stochastic steps: set seeds reproducibility. Expectations prefer Exact equality: expect_identical() (strictest). Numeric comparisons: expect_equal(..., tolerance = 1e-8) (floating point). Types/classes: expect_s3_class(obj, \"data.frame\"). Names/columns: expect_named(df, c(\"sample_id\",\"metabolite\",\"intensity\")). Logical properties: expect_true((df$intensity >= 0)). Errors, warnings, messages Data-frame outputs Check structure exact values appropriate: Fixtures & temporary files Put tiny example inputs tests/testthat/fixtures/ (inst/extdata/ examples). Use withr::local_tempdir() / local_tempfile() avoid polluting repo. Load fixture paths via testthat::test_path(\"fixtures\", \"tiny_input.csv\").","code":"expect_error(fn(bad_arg), class = \"my_pkg_error\")     # classed errors expect_warning(fn(x), \"deprecated\")                   # or a pattern expect_message(fn(verbose = TRUE), \"Completed step\") out <- normalize_intensity(df, method = \"median\") expect_s3_class(out, \"data.frame\") expect_true(all(c(\"sample_id\",\"metabolite\",\"intensity_norm\") %in% names(out))) expect_equal(nrow(out), nrow(df))"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/developer-guidelines.html","id":"tests-directory-structure-naming","dir":"Articles","previous_headings":"Welcome","what":"Tests Directory Structure & Naming","title":"Developers & Contributors","text":"Recommended layout Files tests/testthat.R: One file per exported function cohesive feature, e.g., test-normalize_intensity.R, test-impute_values.R, test-integration-process_data.R. Fixtures (tiny static inputs) go tests/testthat/fixtures/. Naming conventions Files: test-<function_or_feature>.R Tests: clear, behavior-oriented descriptions, e.g., test_that(\"process_data() errors missing required columns\", { ... }).","code":"OmicsProcessing/ ├─ R/ ├─ tests/ │  ├─ testthat.R │  └─ testthat/ │     ├─ test-process_data.R │     ├─ test-normalize_intensity.R │     ├─ test-impute_values.R │     ├─ helper-setup.R │     └─ fixtures/ │        ├─ tiny_input.csv │        └─ tiny_metadata.csv └─ ... library(testthat) library(OmicsProcessing) test_check(\"OmicsProcessing\")"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/developer-guidelines.html","id":"running-unit-tests","dir":"Articles","previous_headings":"Welcome","what":"Running Unit Tests","title":"Developers & Contributors","text":"Everything Filter file name Coverage (optional encouraged)","code":"devtools::test() devtools::test(filter = \"normalize_intensity\") # matches file or test name testthat::test_file(\"tests/testthat/test-impute_values.R\") covr::report()   # opens HTML coverage report"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/feature-clustering.html","id":"cluster-features-by-retention-time","dir":"Articles","previous_headings":"","what":"Cluster features by retention time","title":"Feature clustering by retention time","text":"cluster_features_by_retention_time() groups features elute together, based similar retention times (RTs). returns data frame includes unclustered features unchanged, plus one representative per cluster. representatives_map output shows original features representative corresponds . See function reference details: cluster_features_by_retention_time(). Prerequisites: use imputed normalised data applying RT clustering. procedure assumes missing values benefits stabilised intensity profiles. is_qc argument prevents QC-designated rows contributing clustering. Typically, is_qc set NULL samples contribute.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/feature-clustering.html","id":"how-representatives-are-selected-with-the-scores-method","dir":"Articles","previous_headings":"Cluster features by retention time","what":"How representatives are selected with the “scores” method","title":"Feature clustering by retention time","text":"“scores” method clusters features RT returns one representative per RT cluster based input score. employs get_features_representatives_based_on_scores(). helper called internally cluster_features_by_retention_time(); need invoke explicitly. RT-based cluster: Single-feature clusters: feature returned unchanged. Multi-feature clusters: feature highest score selected representative, representatives_map records members represents.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/feature-clustering.html","id":"example-1-score-based-representatives-mean-intensity-before-normalisation","dir":"Articles","previous_headings":"Cluster features by retention time","what":"Example 1: Score-based representatives (mean intensity before normalisation)","title":"Feature clustering by retention time","text":"rt_height parameter defines maximum RT span forming cluster: features whose RTs differ less value grouped. Within cluster, supplied scores determine representative. example, pre-normalisation mean intensities serve scores; consequently, representative feature highest mean intensity normalisation. representatives_map lists representatives names, vectors raw feature names values.","code":"# Assume `imputed_df` is your imputed, SERRF-normalised data # Use pre-normalisation means as scores target_cols <- OmicsProcessing::resolve_target_cols(clean_df, \"@\") scores <- colMeans(pre_normalised_df[, target_cols])  res_scores <- OmicsProcessing::cluster_features_by_retention_time(   df = normalised_df,   target_cols = target_cols,   rt_height = 0.07,   method = \"scores\",   scores = scores )  clustered_df <- res_scores$clustered_df     # original features + representatives rep_map <- res_scores$representatives_map   # mapping of representatives to raw features"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/feature-clustering.html","id":"how-representatives-are-selected-with-the-correlation-method","dir":"Articles","previous_headings":"Cluster features by retention time","what":"How representatives are selected with the correlation method","title":"Feature clustering by retention time","text":"method = \"correlations\", features first grouped together rt_height (like scores method). , secondary correlation-based clustering step applied within RT-defined group. Clustering behaviour governed corr_thresh cut_height: RT cluster size 1: retained unchanged. RT cluster size 2: |corr| ≥ corr_thresh, pair summarised synthetic PC1 feature. Otherwise, features retained. RT cluster size ≥3: hierarchical clustering (ClustOfVar) cut cut_height, resulting sub-cluster summarised synthetic PC1, aligned first feature sub-cluster. cases, representatives_map lists synthetic feature names records raw features incorporated synthetic representative.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/feature-clustering.html","id":"example-2-correlation-based-summarisation-within-rt-clusters","dir":"Articles","previous_headings":"Cluster features by retention time","what":"Example 2: Correlation-based summarisation within RT clusters","title":"Feature clustering by retention time","text":"","code":"res_corr <- OmicsProcessing::cluster_features_by_retention_time(   df = normalised_df,   target_cols = \"@\",   is_qc = grepl(\"^sQC\", normalised_df$sample_type),   rt_height = 0.07,   method = \"correlations\",   cut_height = 0.26,   corr_thresh = 0.75 )  clustered_df_corr <- res_corr$clustered_df rep_map_corr <- res_corr$representatives_map"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/feature-clustering.html","id":"tips","dir":"Articles","previous_headings":"Cluster features by retention time","what":"Tips","title":"Feature clustering by retention time","text":"Set rt_height reflect instrument’s RT precision; smaller values produce , tighter, RT clusters. \"scores\", ensure scores named numeric vector aligned target_cols. Using pre-normalisation means simple efficient strategy. \"correlations\", tune cut_height corr_thresh adjust merging stringency correlated features. Always inspect representatives_map understand representative relates original features, particularly reporting, audit trails, sensitivity analyses.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/hybrid-imputation.html","id":"step-4-hybrid-imputation-random-forest-lcmd","dir":"Articles","previous_headings":"","what":"Step 4: Hybrid Imputation (Random Forest + LCMD)","title":"Hybrid imputation with RF + LCMD","text":"hybrid_imputation() combines two complementary strategies: Random Forest (RF) via missForest::missForest() features well-predicted variables (low OOBE). Left-Censored Missing Data (LCMD) via imputeLCMD::impute.MAR.MNAR() features higher OOBE. function fits RF per feature, uses --bag error (OOBE) decide whether keep RF estimate switch feature LCMD, returns: hybrid_rf_lcmd: combined result. rf / lcmd: per-method outputs. oob: OOBE values (helpful diagnostics). See full reference: hybrid_imputation().","code":"imputed_results <- OmicsProcessing::hybrid_imputation(   log_transformed_df,   target_cols = \"@\",   method = c(\"RF-LCMD\"),   oobe_threshold = 0.1 ) imputed_df <- imputed_results$hybrid_rf_lcmd"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/hybrid-imputation.html","id":"customising-the-rf-and-lcmd-controls","dir":"Articles","previous_headings":"Step 4: Hybrid Imputation (Random Forest + LCMD)","what":"Customising the RF and LCMD controls","title":"Hybrid imputation with RF + LCMD","text":"can tweak engines via control lists:","code":"my_control_RF <- list(   parallelize = \"no\",   mtry = floor(sqrt(length(target_cols))),   ntree = 100,   maxiter = 10,   variablewise = TRUE,   verbose = TRUE,   n_cores = parallel::detectCores() )  my_control_LCMD <- list(   method.MAR = \"KNN\",   method.MNAR = \"QRILC\" )  df_rf_lcmd_hybrid <- OmicsProcessing::hybrid_imputation(   log_transformed_df,   target_cols = \"@\",   method = c(\"RF-LCMD\"),   oobe_threshold = 0.1,   control_LCMD = my_control_LCMD,   control_RF = my_control_RF )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/hybrid-imputation.html","id":"parallelising-the-rf-step-missforest","dir":"Articles","previous_headings":"Step 4: Hybrid Imputation (Random Forest + LCMD)","what":"Parallelising the RF step (missForest)","title":"Hybrid imputation with RF + LCMD","text":"missForest can run parallel register foreach backend set parallelize: Guidance: Use parallelize = \"variables\" many features; \"forests\" spreads trees instead. Keep ntree reasonable parallelising avoid memory pressure. Tips: Keep target_cols explicit possible clarity; \"@\" use feature columns resolved via resolve_target_cols(). Inspect imputed_results$oob confirm RF ↔︎ LCMD split aligns expectations. wide matrices, tune ntree, mtry, number worker cores balance runtime stability.","code":"library(doParallel)  n_cores <- parallel::detectCores(logical = FALSE) cl <- parallel::makeCluster(n_cores) doParallel::registerDoParallel(cl)  ctrl_parallel_RF <- list(   parallelize = \"variables\", # or \"forests\"   mtry = floor(sqrt(length(target_cols))),   ntree = 200,   maxiter = 10,   variablewise = TRUE,   verbose = TRUE )  imputed_parallel <- OmicsProcessing::hybrid_imputation(   log_transformed_df,   target_cols = \"@\",   method = \"RF-LCMD\",   oobe_threshold = 0.1,   control_RF = ctrl_parallel_RF )  parallel::stopCluster(cl) doParallel::registerDoSEQ()"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/log-transformation.html","id":"step-3-log-transformation","dir":"Articles","previous_headings":"","what":"Step 3: Log transformation","title":"Log transformation with log1p()","text":"Apply natural log transform +1 offset across feature columns. resolve_target_cols() lets declare feature set via names, tidyselect helpers, regex (e.g., \"^met_\", \"feature[0-9]+\", \"@\" use feature columns). resulting log1p scaling often reduces skewness, stabilizes variance, moderates influence extreme values without discarding zeros.","code":"feature_cols <- OmicsProcessing::resolve_target_cols(clean_df, \"@\") log_transformed_df <- clean_df %>%   dplyr::mutate(dplyr::across(     .cols = tidyselect::all_of(feature_cols),     .fns = ~ log1p(.x),     .names = \"{.col}\"   ))"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/log-transformation.html","id":"why-use-log1p","dir":"Articles","previous_headings":"Step 3: Log transformation","what":"Why use log1p?","title":"Log transformation with log1p()","text":"Handles zeros gracefully (need add pseudo-count manually). Produces smoother distributions friendlier downstream modeling distance-based methods. Keeps column naming intact via .names = \"{.col}\", can swap transformed data back pipeline without additional renaming.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/log-transformation.html","id":"tips-for-choosing-feature-columns","dir":"Articles","previous_headings":"Step 3: Log transformation","what":"Tips for choosing feature columns","title":"Log transformation with log1p()","text":"Prefer explicit targets clarity: e.g., resolve_target_cols(clean_df, c(\"met_a\", \"met_b\")). Regex tidyselect helpers useful wide matrices: resolve_target_cols(clean_df, tidyselect::starts_with(\"met_\")). Ensure feature columns numeric; convert factors/characters transformation avoid unintended NAs.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/outlier-removal.html","id":"outlier-removal-using-pca-lof","dir":"Articles","previous_headings":"","what":"Outlier removal using PCA + LOF","title":"Outlier removal with remove_outliers()","text":"function detects removes outliers dataset using PCA + Local Outlier Factor (LOF) workflow. Outliers identified among non-QC samples. Missing values can imputed temporarily detection, original NAs can restored afterward. return_ggplots = TRUE, PCA plots returned (see notes ). See remove_outliers().","code":"outlier_results <- OmicsProcessing::remove_outliers(   filtered_df,   target_cols = \"@\",   is_qc = grepl(\"^sQC\", filtered_df$sample_type),   method = \"pca-lof-overall\",   impute_method = \"half-min-value\",   restore_missing_values = TRUE,   return_ggplots = TRUE ) clean_df <- outlier_results$df_filtered"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/outlier-removal.html","id":"optional-stratified-outlier-detection-strata","dir":"Articles","previous_headings":"Outlier removal using PCA + LOF","what":"Optional: stratified outlier detection (strata)","title":"Outlier removal with remove_outliers()","text":"default, stratification used (non-QC samples assessed together). can optionally provide stratification variable outlier detection runs independently within stratum, results merged: Supply strata either: name column df, external vector length nrow(df) (e.g., custom grouping). Within stratum: QC rows excluded detection (always kept final output). impute_method = \"half-min-value\", imputation performed within stratum target_cols. PCA → LOF → Tukey thresholding applied identify outliers. function returns union outlier sample IDs across strata removes non-QC portion recombining QC rows. return_ggplots = TRUE, ’ll get named list per-stratum plots outlier_results$plot_samples_outlier. Examples","code":"## 1) No stratification (default) res <- OmicsProcessing::remove_outliers(   df,    target_cols = c(\"f1\",\"f2\",\"f3\"),   is_qc = df$sample_type == \"sQC\" )  ## 2) Stratify by a column (e.g., batch) res_batch <- OmicsProcessing::remove_outliers(   df,    target_cols = c(\"f1\",\"f2\",\"f3\"),   is_qc = df$sample_type == \"sQC\",   strata = \"batch\",   return_ggplots = TRUE )  ## 3) Stratify by an external vector grp <- ifelse(df$center %in% c(\"C1\",\"C2\"), \"C12\", \"C3\") res_grp <- OmicsProcessing::remove_outliers(   df,    target_cols = tidyselect::starts_with(\"feat_\"),   is_qc = df$sample_type == \"sQC\",   strata = grp,   restore_missing_values = TRUE )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/outlier-removal.html","id":"implementation-notes-requirements","dir":"Articles","previous_headings":"Outlier removal using PCA + LOF","what":"Implementation notes & requirements","title":"Outlier removal with remove_outliers()","text":"PCA: implemented via stats::prcomp(). LOF distances: computed bigutilsr::LOF(). Outlier thresholding: via bigutilsr::tukey_mc_up(). Practical constraints: must enough non-QC samples per stratum PCA LOF meaningful. small strata (e.g., < ~8–10 samples) may yield unstable invalid LOF results. Features target_cols numeric, infinite values; missing values handled optional imputation step constant/zero-variance features can break PCA. LOF requires number neighbors (K); stratum samples relative K, LOF() may error degenerate. rule thumb, ensure n_samples_stratum >> K. high p/n ratios (many features samples) can make PCA LOF unstable. Consider filtering features running step. ggplot generation requires least 10 feature columns target_cols. fewer 10 provided, plots generated; cases leave return_ggplots = FALSE (default). Returned values df_filtered: input df detected outlier non-QC rows removed (QC rows always retained). excluded_ids: vector removed row names (union across strata). plot_samples_outlier: NULL named list ggplot objects (one per stratum) return_ggplots = TRUE length(target_cols) >= 10.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/outlier-removal.html","id":"how-lof-works-in-pca-space-extra-detail","dir":"Articles","previous_headings":"Outlier removal using PCA + LOF","what":"How LOF works in PCA space (extra detail)","title":"Outlier removal with remove_outliers()","text":"Outliers identified using Local Outlier Factor (LOF) algorithm applied PCA-reduced space. LOF detects locally sparse samples relative neighbours, improving data consistency reducing technical noise. Extended description: LOF density-based algorithm compares local density point neighbours. first finds k nearest neighbours (typically Euclidean distance) computes point’s local reachability density (LRD)—inverse average reachability distance reflects local crowding. Points dense regions high LRD; points sparse regions low LRD. LOF score ratio neighbours’ average LRD point’s LRD; values near 1 indicate typical density, values well 1 signal local sparsity potential outliers. LOF runs PCA space (e.g., first 10 principal components), assesses local density reduced subspace capturing dominant structure variance. projection trims noise redundancy correlated features, improving robustness efficiency. Samples high LOF scores locally isolated relative main patterns reduced space—indicating may biologically, technically, experimentally unusual rather random fluctuations.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/process_data.html","id":"the-process_data-documentation","dir":"Articles","previous_headings":"","what":"The process_data() documentation","title":"Semi-automated pipeline with process_data()","text":"package provides general function process_data() pre-analysis processing omics data (e.g., metabolomics/proteomics). processing steps optional can tailored users specific requirements. function performs following processing steps (order): Excludes features extreme missingness based specified threshold Excludes samples extreme missingness based specified threshold Imputes missing values using various methods Transforms data using specified methods Excludes outlying samples using PCA LOF Handles case-control data ensure matched samples treated appropriately Corrects plate effects using specified random fixed effects Centers scales data Requires 3 data frames: column 1 = sample IDs; column 2-N = features example data: data(\"data_features\") column 1 = feature column names; column 2-N = feature information (e.g., % missing, LOD) example data: data(\"data_meta_features\") column 1 = sample IDs; column 2-N = sample information (e.g., batch, age, sex) example data: data(\"data_meta_samples\") Returns list : df_features: processed feature dataframe df_meta_samples: filtered sample meta-data df_meta_features: filteres feature meta-data plot_samples_outlier: figure PCA/LOF analysis id_features_exclude: feature IDs excluded extreme sample missingness id_samples_exclude: sample IDs excluded extreme sample missingness id_samples_outlier: sample IDs excluded PCA/LOF analysis id_samples_casecontrol: sample IDs excluded matched case-control excluded","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/process_data.html","id":"how","dir":"Articles","previous_headings":"","what":"How","title":"Semi-automated pipeline with process_data()","text":"arguments independent examples given . function (e.g., impute_data()) can used independently process_data()","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/process_data.html","id":"sample-and-feature-exclusions-for-10-missingness","dir":"Articles","previous_headings":"How","what":"Sample and feature exclusions for >10% missingness","title":"Semi-automated pipeline with process_data()","text":"","code":"data_processed <- process_data(   data = data_features,    col_samples = \"ID_sample\",    exclusion_extreme_feature = TRUE, missing_pct_feature = 0.1,   exclusion_extreme_sample = TRUE, missing_pct_sample = 0.1)  # Exclusion features: excluding features with more than 10% missingness  ## Exclusion features: excluded 44 feature(s)  # Exclusion samples: excluding samples with more than 10% missingness  ## Exclusion samples: excluded 15 sample(s)  ### total feature(s) excluded = 44  ### total sample(s) excluded = 15  # returning a list of data and exclusion IDs"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/process_data.html","id":"imputation-of-missing-feature-data","dir":"Articles","previous_headings":"How","what":"Imputation of missing feature data","title":"Semi-automated pipeline with process_data()","text":"imputing using limit detection (LOD) equivalent, must provide feature meta-data file contains column feature names column LOD equivalent:","code":"> data_processed <- process_data( +   data = data_features,  +   col_samples = \"ID_sample\",  +   imputation = TRUE, imputation_method = \"mean\")  ## Imputation using mean  ### total feature(s) excluded = 0  ### total sample(s) excluded = 0  # returning a list of data and exclusion IDs data_processed <- process_data(   data = data_features,    data_meta_features = data_meta_features, col_features = \"ID_feature\", col_LOD = \"LOD\",   col_samples = \"ID_sample\",    imputation = TRUE, imputation_method = \"LOD\")"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/process_data.html","id":"transformation-of-feature-data","dir":"Articles","previous_headings":"How","what":"Transformation of feature data","title":"Semi-automated pipeline with process_data()","text":"Ttransformation log10 methods also perform centering scaling mean 0","code":"> data_processed <- process_data( +   data = data_features,  +   col_samples = \"ID_sample\",  +   transformation = TRUE, transformation_method = \"InvRank\")  ## Transformation using InvRank  ### total feature(s) excluded = 0  ### total sample(s) excluded = 0  # returning a list of data and exclusion IDs"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/process_data.html","id":"sample-outlier-exclusions-based-on-pca-and-lof","dir":"Articles","previous_headings":"How","what":"Sample outlier exclusions based on PCA and LOF","title":"Semi-automated pipeline with process_data()","text":"outlier function creates PCA plot samples coloured LOF. example, can introduce outlier sample multiplying feature values ID_10 1.5:","code":"> data_processed <- process_data( +   data = data_features,  +   col_samples = \"ID_sample\",  +   exclusion_extreme_feature = TRUE, missing_pct_feature = 0.1, +   exclusion_extreme_sample = TRUE, missing_pct_sample = 0.1, +   imputation = TRUE, imputation_method = \"mean\", +   outlier = TRUE)  # Exclusion features: excluding features with more than 10% missingness  ## Exclusion features: excluded 44 feature(s)  # Exclusion samples: excluding samples with more than 10% missingness  ## Exclusion samples: excluded 15 sample(s)  ## Imputation using mean  # Outlier exclusion using PCA and LOF  ## Excluded 0 sample(s) ## Creating sample outlier plot ### total feature(s) excluded = 44  ### total sample(s) excluded = 15  # returning a list of data, outlier plot, and exclusion IDs > data_features_outlier <- data_features %>% +   dplyr::mutate(dplyr::across(2:101, ~ ifelse(dplyr::row_number() == 10, . * 1.5, .))) > data_processed <- process_data( +   data = data_features_outlier, +   col_samples = \"ID_sample\",  +   exclusion_extreme_feature = TRUE, missing_pct_feature = 0.1, +   exclusion_extreme_sample = TRUE, missing_pct_sample = 0.1, +   imputation = TRUE, imputation_method = \"mean\", +   outlier = TRUE)  # Exclusion features: excluding features with more than 10% missingness  ## Exclusion features: excluded 44 feature(s)  # Exclusion samples: excluding samples with more than 10% missingness  ## Exclusion samples: excluded 15 sample(s)  ## Imputation using mean  # Outlier exclusion using PCA and LOF  ## Excluded 1 sample(s) ## Creating sample outlier plot ### total feature(s) excluded = 44  ### total sample(s) excluded = 16  # returning a list of data, outlier plot, and exclusion IDs"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/process_data.html","id":"plate-correction","dir":"Articles","previous_headings":"How","what":"Plate correction","title":"Semi-automated pipeline with process_data()","text":"can perform plate correction providing sample feature meta-data files.","code":"data_processed <- process_data(   data = data_features,    data_meta_samples = data_meta_samples,   col_samples = \"ID_sample\",    data_meta_features = data_meta_features,   col_features = \"ID_feature\",   plate_correction = TRUE,    cols_listRandom = c(\"batch\"),    cols_listFixedToKeep = c(\"age\"),    cols_listFixedToRemove = c(\"sex\"),    col_HeteroSked = NULL)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/process_data.html","id":"other","dir":"Articles","previous_headings":"How","what":"Other","title":"Semi-automated pipeline with process_data()","text":"Centering scaling can performed using centre_scale = TRUE. Centering scaling performed log based transformations point transformation, regardless centre_scale = TRUE. processing case-control data likely want ensure excluded samples matched samples also excluded. can done using case_control = TRUE providing column name data_meta_samples matching factor, col_case_control = case_control_match. processed data, IDs excluded samples features reasons exclusions, outlier plot can saved using save = TRUE providing file path processed data (path_out = path//directory/) exclusion data (path_outliers = path//directory/exclusions/)","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/process_data.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Semi-automated pipeline with process_data()","text":"Viallon V, M, Rinaldi S, et al. New Pipeline Normalization Pooling Metabolomics Data. Metabolites. 2021;11(9):631. Published 2021 Sep 17. doi:10.3390/metabo11090631. {PCPR2}: Fages & Ferrari et al. (2014) Investigating sources variability metabolomic data EPIC study: Principal Component Partial R-square (PC-PR2) method. Metabolomics 10(6): 1074-1083, doi: 10.1007/s11306-014-0647-9 lme4: Bates, D., Mächler, M., Bolker, B., & Walker, S. (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal Statistical Software, 67(1), 1–48. doi.org/10.18637/jss.v067.i01. nlme: Pinheiro, J. C. & Bates, D. M. Mixed-Effects Models S S-PLUS. (Springer, New York, 2000). doi:10.1007/b98882 Markus M. Breunig, Hans-Peter Kriegel, Raymond T. Ng, Jörg Sander. 2000. LOF: identifying density-based local outliers. SIGMOD Rec. 29, 2 (June 2000), 93–104. doi.org/10.1145/335191.335388 Tukey, J. W. Exploratory Data Analysis. (Addison-Wesley Publishing Company, 1977). Hubert, M. Vandervieren, E., (2008), adjusted boxplot skewed distributions, Computational Statistics & Data Analysis, 52, issue 12, p. 5186-5201, EconPapers.repec.org/RePEc:eee:csdana:v:52:y:2008::12:p:5186-5201. implementation sample exclusions R package {bigutilsr} described detail Florian Privé blog post","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/serrf-normalisation.html","id":"batch-correction-using-systematical-error-removal-using-random-forest-serrf","dir":"Articles","previous_headings":"","what":"Batch correction using Systematical Error Removal using Random Forest (SERRF)","title":"Batch correction using SERRF","text":"normalise_SERRF() models unwanted technical variation using QC samples within batch/stratum applies SERRF normalization specified feature columns. Use target_cols select features name, tidyselect helper, regex (resolved via resolve_target_cols()), supply logical is_qc flag row. See reference: normalise_SERRF().","code":"out_serrf <- OmicsProcessing::normalise_SERRF(   imputed_df,   target_cols = \"@\",   is_qc = grepl(\"^sQC\", imputed_df$sample_type),   strata_col = \"batch\"  # omit to treat all samples as one strata )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/serrf-normalisation.html","id":"input-requirements","dir":"Articles","previous_headings":"Batch correction using Systematical Error Removal using Random Forest (SERRF)","what":"Input requirements","title":"Batch correction using SERRF","text":"strata_col: provide batch/strata column exists; omit , dummy single-level strata created samples treated one batch. supplied, coerced factor (NAs). is_qc logical vector length nrow(df); ensure every batch enough QC samples SERRF model. target_cols must numeric contain NA values (impute beforehand). least three target features required (SERRF needs predictors model feature).","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/articles/serrf-normalisation.html","id":"tuning-and-tips","dir":"Articles","previous_headings":"Batch correction using Systematical Error Removal using Random Forest (SERRF)","what":"Tuning and tips","title":"Batch correction using SERRF","text":"num_screen_SERRF (default 10) controls many correlated features screened per target; increase cautiously many features stable QC coverage. Inspect /QC CVs PCA verify batch drift reduced. Keep batches balanced: small batches QC points can lead unstable fits; consider merging sparse strata adding QC possible.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Vivian Viallon. Author. Lee Matthew. Author. Ali Farnudi. Author, maintainer.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Viallon V, Matthew L, Farnudi (2026). OmicsProcessing: OmicsProcessing. R package version 1.1.1.","code":"@Manual{,   title = {OmicsProcessing: OmicsProcessing},   author = {Vivian Viallon and Lee Matthew and Ali Farnudi},   year = {2026},   note = {R package version 1.1.1}, }"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/index.html","id":"omicsprocessing","dir":"","previous_headings":"","what":"OmicsProcessing","title":"OmicsProcessing","text":"Pre-analysis processing metabolomics proteomics: missingness filtering, outlier handling, imputation, transformation, matched case-control handling, batch/plate correction, SERRF-based normalisation across batches strata.","code":""},{"path":[]},{"path":"https://iarcbiostat.github.io/OmicsProcessing/index.html","id":"semi-automated-pipeline-process_data","dir":"","previous_headings":"Choose your workflow","what":"Semi-automated pipeline (process_data())","title":"OmicsProcessing","text":"End--end wrapper can filter missingness, impute, transform, remove outliers (PCA + LOF), handle matched case-control designs, correct plate/batch effects, centre/scale. Takes three data frames (feature data, feature metadata, sample metadata) returns processed data plus exclusion IDs PCA/LOF plots. Full walk-: Semi-automated pipeline.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/index.html","id":"modular-workflow-build-your-own","dir":"","previous_headings":"Choose your workflow","what":"Modular workflow (build your own)","title":"OmicsProcessing","text":"Filter missingness filter_by_missingness() (vignette) Detect outlier samples remove_outliers() (vignette) Impute RF, LCMD, via hybrid_imputation() (vignette) Normalise SERRF using normalise_SERRF() (vignette) Cluster features RT correlations using cluster_features_by_retention_time() (vignette)","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick start","title":"OmicsProcessing","text":"Run semi-automated pipeline three input tables: stitch together modular workflow:","code":"# install.packages(\"remotes\") remotes::install_github(\"IARCBiostat/OmicsProcessing\") library(OmicsProcessing) processed <- process_data(   data = data_features,   data_meta_features = data_meta_features,   data_meta_samples = data_meta_samples,   col_samples = \"ID_sample\",   exclusion_extreme_feature = TRUE,   exclusion_extreme_sample = TRUE,   imputation = TRUE,   transformation = TRUE,   outlier = TRUE,   plate_correction = TRUE ) # Load data df <- readr::read_csv(\"path/to/data\")  # Filter by missingness df_filtered <- filter_by_missingness(   df,   row_thresh = 0.5,   col_thresh = 0.5,   target_cols = \"@\",   is_qc = grepl(\"^sQC\", df$sample_type),   filter_order = \"iterative\" )  # Detect outlier samples (PCA + LOF) outliers <- remove_outliers(   df_filtered,   target_cols = \"@\",   is_qc = grepl(\"^sQC\", df_filtered$sample_type),   method = \"pca-lof-overall\",   impute_method = \"half-min-value\",   restore_missing_values = TRUE,   return_ggplots = FALSE ) df_clean <- outliers$df_filtered  # Log-transform features df_clean <- df_clean %>%   dplyr::mutate(dplyr::across(tidyselect::contains(\"@\"), log1p))  # Impute missing values (RF + LCMD) df_imputed <- hybrid_imputation(   df_clean,   target_cols = \"@\",   method = \"RF-LCMD\",   oobe_threshold = 0.1 )$hybrid_rf_lcmd  # SERRF normalisation df_normalised <- normalise_SERRF(   df_imputed,   target_cols = \"@\",   is_qc = grepl(\"^sQC\", df_imputed$sample_type),   strata_col = \"batch\" )  # Cluster features by RT using correlations clusters <- cluster_features_by_retention_time(   df = df_normalised,   target_cols = \"@\",   rt_height = 0.07,   method = \"correlations\",   cut_height = 0.26,   corr_thresh = 0.75 )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/index.html","id":"developers--contributors","dir":"","previous_headings":"","what":"Developers & Contributors","title":"OmicsProcessing","text":"welcome contributions OmicsProcessing. priorities clean code good documentation. Please follow guidelines: Developers & Contributors","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/index.html","id":"resources","dir":"","previous_headings":"","what":"Resources","title":"OmicsProcessing","text":"Data filtering vignette: Filtering missingness Outlier removal vignette: PCA + LOF outlier detection Hybrid imputation vignette: Random Forest + LCMD Function reference index: functions Semi-automated pipeline details: Semi-automated pipeline vignette Log-transform features: Log transformation (log1p) SERRF batch correction: Batch correction using SERRF Feature clustering: Retention-time clustering Developers & contributors: Developer guide","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/FUNnormalization_residualMixedModels.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Residuals Using Mixed Models — FUNnormalization_residualMixedModels","title":"Compute Residuals Using Mixed Models — FUNnormalization_residualMixedModels","text":"function calculates residuals mixed model remove unwanted effects.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/FUNnormalization_residualMixedModels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Residuals Using Mixed Models — FUNnormalization_residualMixedModels","text":"","code":"FUNnormalization_residualMixedModels(   df,   listRandom,   listFixedToKeep,   listFixedToRemove,   HeteroSked,   i )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/FUNnormalization_residualMixedModels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Residuals Using Mixed Models — FUNnormalization_residualMixedModels","text":"df data frame feature measurements relevant variables. listRandom character vector strings specifying random effect variables. listFixedToKeep character vector strings specifying fixed effect variables keep. listFixedToRemove character vector strings specifying fixed effect variables remove. HeteroSked string NULL. NULL, specifies variable heteroskedasticity correction. string specifying current feature processed.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/FUNnormalization_residualMixedModels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Residuals Using Mixed Models — FUNnormalization_residualMixedModels","text":"numeric vector residuals given feature.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/calculate_ICC.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Intraclass Correlation Coefficient (ICC) — calculate_ICC","title":"Calculate Intraclass Correlation Coefficient (ICC) — calculate_ICC","text":"function calculates Intraclass Correlation Coefficient (ICC) set samples quality controls using linear mixed-effects model. : https://pmc.ncbi.nlm.nih.gov/articles/PMC6570933/ Based : https://github.com/courtneyschiffman/Metabolomics-Filtering/blob/master/ICC.R","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/calculate_ICC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Intraclass Correlation Coefficient (ICC) — calculate_ICC","text":"","code":"calculate_ICC(df, id_samples, id_qc)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/calculate_ICC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Intraclass Correlation Coefficient (ICC) — calculate_ICC","text":"df data frame rows = features columns = samples column names sample IDs; row names feature IDs id_samples vector column names indices representing sample columns df. id_qc vector column names indices representing quality control columns df.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/calculate_ICC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Intraclass Correlation Coefficient (ICC) — calculate_ICC","text":"named numeric vector ICC values row df.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/calculate_ICC_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Intraclass Correlation Coefficient (ICC) parallel — calculate_ICC_parallel","title":"Calculate Intraclass Correlation Coefficient (ICC) parallel — calculate_ICC_parallel","text":"function calculates Intraclass Correlation Coefficient (ICC) set samples quality controls using linear mixed-effects model. : https://pmc.ncbi.nlm.nih.gov/articles/PMC6570933/ Based : https://github.com/courtneyschiffman/Metabolomics-Filtering/blob/master/ICC.R","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/calculate_ICC_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Intraclass Correlation Coefficient (ICC) parallel — calculate_ICC_parallel","text":"","code":"calculate_ICC_parallel(df, id_samples, id_qc)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/calculate_ICC_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Intraclass Correlation Coefficient (ICC) parallel — calculate_ICC_parallel","text":"df data frame rows = features columns = samples column names sample IDs; row names feature IDs id_samples vector column names indices representing sample columns df. id_qc vector column names indices representing quality control columns df.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/calculate_ICC_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Intraclass Correlation Coefficient (ICC) parallel — calculate_ICC_parallel","text":"named numeric vector ICC values row df.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/check_dataframe_validity.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate a Data Frame for LCMD Imputation — check_dataframe_validity","title":"Validate a Data Frame for LCMD Imputation — check_dataframe_validity","text":"Ensures input data frame least 1 column, 2 rows, columns numeric.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/check_dataframe_validity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate a Data Frame for LCMD Imputation — check_dataframe_validity","text":"","code":"check_dataframe_validity(df)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/check_dataframe_validity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate a Data Frame for LCMD Imputation — check_dataframe_validity","text":"df object validated.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/check_dataframe_validity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate a Data Frame for LCMD Imputation — check_dataframe_validity","text":"TRUE input passes checks; otherwise throws error.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cluster_features_based_on_correlations.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster feature groups based on correlations — cluster_features_based_on_correlations","title":"Cluster feature groups based on correlations — cluster_features_based_on_correlations","text":"Given list pre-defined feature groups, construct data set representative features collapsing groups high correlations synthetic variables.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cluster_features_based_on_correlations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster feature groups based on correlations — cluster_features_based_on_correlations","text":"","code":"cluster_features_based_on_correlations(   df,   cluster_feature_list,   cut_height,   corr_thresh )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cluster_features_based_on_correlations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster feature groups based on correlations — cluster_features_based_on_correlations","text":"df tibble data.frame containing feature columns (possibly variables used ). variables referenced cluster_feature_list must columns df. cluster_feature_list list element character vector giving names features belong one initial cluster. Feature names typically form \"RT@mass\", RT mass real numbers corresponding retention time mass, valid column names accepted. cut_height Numeric. Cut-height correlation-based clustering within groups size three (implemented ClustOfVar). suggested value 0.26, corresponds roughly pairwise correlation 0.75. can use dedicated helper (e.g. simul_eval_link_hhh_corr) explore correspondence pairwise correlations tree height returned ClustOfVar::hclustvar(). corr_thresh Numeric. Cut-absolute pairwise correlation used number features group exactly two. absolute correlation two features least corr_thresh, replaced single synthetic feature (first principal component); otherwise original features kept.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cluster_features_based_on_correlations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster feature groups based on correlations — cluster_features_based_on_correlations","text":"list following components: clustered_df tibble one row per observation one column per final representative feature. clusters size one, column original feature. size two correlation corr_thresh, column first principal component two features. larger clusters, columns synthetic variables returned ClustOfVar, oriented positive correlation first feature corresponding sub-cluster. representatives_map named list mapping synthetic feature (columns whose names start \"SynthFeat@\") character vector original feature names summarises. Original features kept appear map.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cluster_features_based_on_correlations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cluster feature groups based on correlations — cluster_features_based_on_correlations","text":"groups size one, original feature kept . groups size two, decision based pairwise correlation. larger groups, clustering based decrease homogeneity ClustOfVar package. homogeneity cluster squared correlation (quantitative variables) variables cluster centre (first principal component). function typically used pre-grouping step (example, retention-time-based grouping). element cluster_feature_list corresponds one pre-defined group may contain one, two, feature names; cases handled. groups size three , hierarchical clustering tree first obtained using ClustOfVar::hclustvar(). tree cut data-driven position derived cut_height, ClustOfVar::cutreevar() used obtain synthetic scores resulting sub-clusters. score multiplied \\(+1\\) \\(-1\\) positive correlation first feature sub-cluster.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cluster_features_based_on_correlations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cluster feature groups based on correlations — cluster_features_based_on_correlations","text":"","code":"set.seed(123) data_tbl <- tibble::tibble(   `100@150` = rnorm(20),   `100@151` = rnorm(20),   `101@200` = rnorm(20) )  # Pre-defined feature groups (e.g. after a retention-time grouping step) cluster_feature_list <- list(   c(\"100@150\", \"100@151\"), # group of size 2   \"101@200\" # group of size 1 )  res <- cluster_features_based_on_correlations(   df = data_tbl,   cluster_feature_list = cluster_feature_list,   cut_height = 0.26,   corr_thresh = 0.75 )  res$clustered_df #>        100@150     100@151     101@200 #> 1  -0.56047565 -1.06782371 -0.69470698 #> 2  -0.23017749 -0.21797491 -0.20791728 #> 3   1.55870831 -1.02600445 -1.26539635 #> 4   0.07050839 -0.72889123  2.16895597 #> 5   0.12928774 -0.62503927  1.20796200 #> 6   1.71506499 -1.68669331 -1.12310858 #> 7   0.46091621  0.83778704 -0.40288484 #> 8  -1.26506123  0.15337312 -0.46665535 #> 9  -0.68685285 -1.13813694  0.77996512 #> 10 -0.44566197  1.25381492 -0.08336907 #> 11  1.22408180  0.42646422  0.25331851 #> 12  0.35981383 -0.29507148 -0.02854676 #> 13  0.40077145  0.89512566 -0.04287046 #> 14  0.11068272  0.87813349  1.36860228 #> 15 -0.55584113  0.82158108 -0.22577099 #> 16  1.78691314  0.68864025  1.51647060 #> 17  0.49785048  0.55391765 -1.54875280 #> 18 -1.96661716 -0.06191171  0.58461375 #> 19  0.70135590 -0.30596266  0.12385424 #> 20 -0.47279141 -0.38047100  0.21594157 res$representatives_map #> list()"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cluster_features_by_retention_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster features by retention time and summarise within clusters — cluster_features_by_retention_time","title":"Cluster features by retention time and summarise within clusters — cluster_features_by_retention_time","text":"Groups features clusters based retention time using hierarchical clustering, selects representative feature cluster either via scores via correlation-based aggregation.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cluster_features_by_retention_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster features by retention time and summarise within clusters — cluster_features_by_retention_time","text":"","code":"cluster_features_by_retention_time(   df,   target_cols = NULL,   is_qc = NULL,   rt_height = 0.07,   method = c(\"correlations\", \"scores\"),   scores = NULL,   cut_height = NULL,   corr_thresh = NULL )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cluster_features_by_retention_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster features by retention time and summarise within clusters — cluster_features_by_retention_time","text":"df data.frame (tibble) feature data columns samples rows. target_cols Character vector feature/column names use. NULL, resolve_target_cols() used determine set features. is_qc Logical vector marking QC samples. Must length equal nrow(df). NULL, samples treated non-QC. (Currently used consistency interfaces; used directly function.) rt_height Numeric height cut dendrogram retention-time space. Smaller values create clusters. method Character string indicating obtain single representative per retention-time cluster. Either \"correlations\" \"scores\". \"scores\", one existing feature per cluster selected based pre-computed scores. \"correlations\", clusters processed using correlation-based summarisation. scores Named numeric vector feature scores, required method = \"scores\". Names must coincide target_cols. retention-time cluster, feature  subclusterd based input correlation threshold. feature highest score selected representative subcluster. cut_height Numeric height used inside cluster_features_based_on_correlations method = \"correlations\". Passed function's cut_height argument. corr_thresh Numeric threshold used inside cluster_features_based_on_correlations method = \"correlations\". Passed function's corr_thresh argument.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cluster_features_by_retention_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster features by retention time and summarise within clusters — cluster_features_by_retention_time","text":"list two elements: clustered_df data.frame one column per final representative feature. method = \"scores\", consists subset original feature columns. method = \"correlations\", may contain synthetic features created cluster_features_based_on_correlations(). representatives_map named list mapping representative feature (original synthetic) character vector feature names represents within retention-time cluster.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cluster_features_by_retention_time.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cluster features by retention time and summarise within clusters — cluster_features_by_retention_time","text":"function proceeds two steps: Retention-time clustering: feature names target_cols first parsed using parse_mass_rt() extract retention times, clustered cluster_hierarchical() height rt_height. yields groups features similar retention times. Within-cluster summarisation: method = \"scores\", retention-time cluster reduced single original feature using get_features_representatives_based_on_scores(), based supplied scores. method = \"correlations\", retention-time cluster passed feature list cluster_features_based_on_correlations(), may split summarise cluster synthetic variables based correlations.","code":""},{"path":[]},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cluster_features_by_retention_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cluster features by retention time and summarise within clusters — cluster_features_by_retention_time","text":"","code":"if (FALSE) { # \\dontrun{ df <- data.frame(   `100@150` = rnorm(20),   `100@151` = rnorm(20),   `101@200` = rnorm(20) )  target_cols <- c(\"100@150\", \"100@151\", \"101@200\") is_qc <- rep(FALSE, nrow(df))  ## Using scores to pick one feature per RT cluster scores <- c(   `100@150` = 0.2,   `100@151` = 0.8,   `101@200` = 0.5 )  res_scores <- cluster_features_by_retention_time(   df = df,   target_cols = target_cols,   is_qc = is_qc,   rt_height = 0.07,   method = \"scores\",   scores = scores )  ## Using correlation-based summarisation within RT clusters res_corr <- cluster_features_by_retention_time(   df = df,   target_cols = target_cols,   is_qc = is_qc,   rt_height = 0.07,   method = \"correlations\",   cut_height = 0.26,   corr_thresh = 0.75 ) } # }"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cols_keep_from_rows.html","id":null,"dir":"Reference","previous_headings":"","what":"Select target columns to keep based on missingness — cols_keep_from_rows","title":"Select target columns to keep based on missingness — cols_keep_from_rows","text":"Computes per-column NA proportions provided non-QC rows dataset returns subset target columns meet threshold.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cols_keep_from_rows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select target columns to keep based on missingness — cols_keep_from_rows","text":"","code":"cols_keep_from_rows(df, rows_idx_non_qc, target_cols, col_thresh)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cols_keep_from_rows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select target columns to keep based on missingness — cols_keep_from_rows","text":"df data.frame. rows_idx_non_qc Integer indices rows include calculation (exclude QC rows). target_cols Character vector target column names. col_thresh Numeric. Maximum allowed proportion missing values per column.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/cols_keep_from_rows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select target columns to keep based on missingness — cols_keep_from_rows","text":"Character vector target column names keep.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/data_check.html","id":null,"dir":"Reference","previous_headings":"","what":"check required columns — data_check","title":"check required columns — data_check","text":"function checks presence required columns verifies necessary columns present based specified exclusion flags.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/data_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check required columns — data_check","text":"","code":"data_check(   data,   data_meta_features,   data_meta_samples,   col_samples,   col_features = NULL,   exclusion_extreme_feature = FALSE,   exclusion_extreme_sample = FALSE,   missing_pct_feature = NULL,   missing_pct_sample = NULL )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/data_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"check required columns — data_check","text":"data Data frame containing sample data, must include col_samples. data_meta_features Data frame containing feature metadata, must include col_features data_meta_samples Data frame containing sample metadata, must include col_samples col_samples Character vector specifying column name(s) data representing sample IDs. col_features Character string specifying column name data_meta_features representing feature IDs (optional, checked provided). exclusion_extreme_feature Logical; TRUE, missing_pct_feature must provided exist data_meta_features. exclusion_extreme_sample Logical; TRUE, missing_pct_sample must provided exist data_meta_samples. missing_pct_feature Numeric value indicating acceptable percentage missing data features (required exclusion_extreme_feature TRUE). missing_pct_sample Numeric value indicating acceptable percentage missing data samples (required exclusion_extreme_sample TRUE).","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/data_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"check required columns — data_check","text":"Logical; TRUE required columns present, otherwise error raised.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/data_features.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Dataframe 1 — data_features","title":"Simulated Dataframe 1 — data_features","text":"simulated dataframe 100 rows 101 columns. Col1 ID column. remaining columns features randomly assigned values. values assigned, feature missingness introduced (5 percent) randomly feature_2-feature_92. feature_93-feature_100 contains missing 10, 20, 30, 40, 50, 60, 70, 80, 90 perceent, respectively. Sample missingness intriduced ID_90-ID_100 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 perceent, respectively. Missing values ID_1 replaced mean feature give ID_1 missingness","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/data_features.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Dataframe 1 — data_features","text":"","code":"data(data_features)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/data_features.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated Dataframe 1 — data_features","text":"data frame 100 rows 101 variables:","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/data_meta_features.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Dataframe 2 — data_meta_features","title":"Simulated Dataframe 2 — data_meta_features","text":"dataframe summarizing missing values minimum values df1.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/data_meta_features.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Dataframe 2 — data_meta_features","text":"","code":"data(data_meta_features)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/data_meta_features.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated Dataframe 2 — data_meta_features","text":"data frame 100 rows 3 variables: ID_feature Feature names data missing_pct percentage missing values feature LOD limit detection minimum feature value / 2","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/data_meta_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Dataframe 3 — data_meta_samples","title":"Simulated Dataframe 3 — data_meta_samples","text":"dataframe ID, batch, sex, age information.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/data_meta_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Dataframe 3 — data_meta_samples","text":"","code":"data(data_meta_samples)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/data_meta_samples.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated Dataframe 3 — data_meta_samples","text":"data frame 100 rows 4 variables: ID_sample ID ID_sample column data batch randomly assigned levels (N = 10) sex randomly assigned 1 2 age mean 55; SD 10","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/exclude_features.html","id":null,"dir":"Reference","previous_headings":"","what":"Exclude features with X misingness — exclude_features","title":"Exclude features with X misingness — exclude_features","text":"function excludes features dataset (df) based specified threshold missing data percentage meta data file.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/exclude_features.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exclude features with X misingness — exclude_features","text":"","code":"exclude_features(df, missing_pct_feature = NULL)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/exclude_features.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exclude features with X misingness — exclude_features","text":"df data frame feature data missing_pct_feature Numeric, threshold (0 1) feature missing data exclusion (e.g., 0.2 20%).","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/exclude_features.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exclude features with X misingness — exclude_features","text":"list containing: df filtered data frame excluded features removed. excluded_features vector names features excluded.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/exclude_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Exclude samples with X missingness — exclude_samples","title":"Exclude samples with X missingness — exclude_samples","text":"function excludes samples dataset (df) based specified threshold missing data percentage meta data file.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/exclude_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exclude samples with X missingness — exclude_samples","text":"","code":"exclude_samples(df, missing_pct_sample = NULL)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/exclude_samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exclude samples with X missingness — exclude_samples","text":"df data frame feature data missing_pct_sample Numeric, threshold (0 1) sample missing data exclusion (e.g., 0.2 20%).","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/exclude_samples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exclude samples with X missingness — exclude_samples","text":"list containing: df filtered data frame excluded samples removed. excluded_samples vector names samples excluded.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_by_missingness.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter a data.frame by missingness in rows and columns — filter_by_missingness","title":"Filter a data.frame by missingness in rows and columns — filter_by_missingness","text":"Applies different strategies filter rows columns dataset based missingness thresholds. Supports iterative refinement stable.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_by_missingness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter a data.frame by missingness in rows and columns — filter_by_missingness","text":"","code":"filter_by_missingness(   df,   row_thresh = 0.5,   col_thresh = 0.5,   target_cols = NULL,   is_qc = NULL,   filter_order = c(\"iterative\", \"simultaneous\", \"col_then_row\", \"row_then_col\"),   max_iter = 10 )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_by_missingness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter a data.frame by missingness in rows and columns — filter_by_missingness","text":"df data.frame. row_thresh Proportion missing values allowed per (non-QC) row target columns. col_thresh Proportion missing values allowed per column target columns. target_cols Character vector target columns. NULL, resolved resolve_target_cols(). is_qc Logical vector length nrow(df) indicating QC rows (always retained). filter_order One \"iterative\" (default), \"col_then_row\", \"row_then_col\", \"simultaneous\". \"iterative\": alternately filter rows columns stable max_iter reached. \"col_then_row\": filter columns first, rows. \"row_then_col\": filter rows first, columns. \"simultaneous\": filter rows columns independently, intersect results. max_iter Maximum number iterations filter_order=\"iterative\". Default 10.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_by_missingness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter a data.frame by missingness in rows and columns — filter_by_missingness","text":"Filtered data.frame subset rows /columns.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_by_missingness.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter a data.frame by missingness in rows and columns — filter_by_missingness","text":"","code":"# Example dataset with deliberate missingness df <- data.frame(   a = c(NA, 1, NA, 1, NA),   b = c(NA, NA, 2, 2, NA),   c = c(3, NA, NA, 3, NA),   d = 1 )  # Mark row 2 and 5 as QC (always kept, but excluded from filtering thresholds) is_qc <- c(FALSE, TRUE, FALSE, FALSE, TRUE) target_cols <- c(\"a\",\"b\",\"c\")  # Original print(df) #>    a  b  c d #> 1 NA NA  3 1 #> 2  1 NA NA 1 #> 3 NA  2 NA 1 #> 4  1  2  3 1 #> 5 NA NA NA 1 #    a  b  c d # 1 NA NA  3 1 # 2  1 NA NA 1 # 3 NA  2 NA 1 # 4  1  2  3 1 # 5 NA NA NA 1  # Iterative filtering print(filter_by_missingness(df, row_thresh=0.5, col_thresh=0.5,                             target_cols=target_cols, is_qc=is_qc,                             filter_order=\"iterative\")) #>    b  c d #> 1 NA  3 1 #> 2 NA NA 1 #> 3  2 NA 1 #> 4  2  3 1 #> 5 NA NA 1 # [1] \"iteration\" #    b  c d # 1 NA  3 1 # 2 NA NA 1 # 3  2 NA 1 # 4  2  3 1 # 5 NA NA 1  # Simultaneous filtering print(filter_by_missingness(df, row_thresh=0.5, col_thresh=0.5,                             target_cols=target_cols, is_qc=is_qc,                             filter_order=\"simultaneous\")) #>    b  c d #> 2 NA NA 1 #> 4  2  3 1 #> 5 NA NA 1 # [1] \"simultaneous\" #    b  c d # 2 NA NA 1 # 4  2  3 1 # 5 NA NA 1  # Column-then-row filtering print(filter_by_missingness(df, row_thresh=0.5, col_thresh=0.5,                             target_cols=target_cols, is_qc=is_qc,                             filter_order=\"col_then_row\")) #>    b  c d #> 1 NA  3 1 #> 2 NA NA 1 #> 3  2 NA 1 #> 4  2  3 1 #> 5 NA NA 1 #    b  c d # 1 NA  3 1 # 2 NA NA 1 # 3  2 NA 1 # 4  2  3 1 # 5 NA NA 1  # Row-then-column filtering print(filter_by_missingness(df, row_thresh=0.5, col_thresh=0.5,                             target_cols=target_cols, is_qc=is_qc,                             filter_order=\"row_then_col\")) #>    a  b  c d #> 2  1 NA NA 1 #> 4  1  2  3 1 #> 5 NA NA NA 1 #    a  b  c d # 2  1 NA NA 1 # 4  1  2  3 1 # 5 NA NA NA 1  # For this simple data set the \"iteration\" and the \"col_then_row\" filtering results are the same."},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_case_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter Samples Based on Case Control Criteria — filter_case_control","title":"Filter Samples Based on Case Control Criteria — filter_case_control","text":"function filters samples provided data frame based case control criteria. excludes individuals without matched caseset matched casesets two individuals. also provides information excluded samples.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_case_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter Samples Based on Case Control Criteria — filter_case_control","text":"","code":"filter_case_control(df, df_meta_samples, col_case_control, col_samples)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_case_control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter Samples Based on Case Control Criteria — filter_case_control","text":"df data frame containing feature data rows represent samples columns represent features. df_meta_samples data frame containing sample metadata least column specified col_case_control. col_case_control string specifying column name df_meta_samples indicates case control groups. col_samples string specifying column name df_meta_samples use sample filtering (e.g., ID column).","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_case_control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter Samples Based on Case Control Criteria — filter_case_control","text":"list containing: filtered_df: filtered feature data frame. filtered_samples: filtered sample data frame. excluded_ids: vector IDs excluded samples.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_function_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter a list to match the formal arguments of a target function — filter_function_args","title":"Filter a list to match the formal arguments of a target function — filter_function_args","text":"Removes elements list formal arguments specified function. Optionally emits warning discarded elements.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_function_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter a list to match the formal arguments of a target function — filter_function_args","text":"","code":"filter_function_args(args, fun, warn = TRUE)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_function_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter a list to match the formal arguments of a target function — filter_function_args","text":"args named list arguments (e.g., user-supplied control list). fun function object function name match arguments . warn Logical; TRUE, warns arguments dropped. Default TRUE.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_function_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter a list to match the formal arguments of a target function — filter_function_args","text":"filtered list containing arguments accepted function.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/filter_function_args.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter a list to match the formal arguments of a target function — filter_function_args","text":"","code":"control <- list(ntree = 100, bogus = 1) clean_args <- filter_function_args(control, missForest::missForest) #> Warning: The following arguments are not accepted by missForest::missForest and were ignored: bogus # bogus is removed"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/final_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Finalize kept columns — final_cols","title":"Finalize kept columns — final_cols","text":"Always keeps non-target columns alongside retained target columns.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/final_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finalize kept columns — final_cols","text":"","code":"final_cols(target_cols_kept, non_target_cols, all_names)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/final_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finalize kept columns — final_cols","text":"target_cols_kept Character vector retained target columns. non_target_cols Character vector non-target column names. all_names Character vector column names dataset.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/final_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finalize kept columns — final_cols","text":"Character vector final kept column names.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/generate_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"generate labels — generate_labels","title":"generate labels — generate_labels","text":"function creates labels saving based several data processing options (e.g., exclusion, imputation, transformation, outlier handling, etc.). returns list character labels indicate specified settings, can used file naming tracking parameter choices.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/generate_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"generate labels — generate_labels","text":"","code":"generate_labels(   exclusion_extreme_feature,   missing_pct_feature = NULL,   exclusion_extreme_sample,   missing_pct_sample = NULL,   imputation,   imputation_method = NULL,   transformation,   transformation_method = NULL,   outlier,   plate_correction,   centre_scale )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/generate_labels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"generate labels — generate_labels","text":"exclusion_extreme_feature Logical, whether extreme feature exclusion applied. missing_pct_feature Numeric, percentage threshold excluding features based missing data (used exclusion_extreme_feature TRUE). exclusion_extreme_sample Logical, whether extreme sample exclusion applied. missing_pct_sample Numeric, percentage threshold excluding samples based missing data (used exclusion_extreme_sample TRUE). imputation Logical, whether imputation applied. imputation_method Character, method used imputation (used imputation TRUE). transformation Logical, whether data transformation applied. transformation_method Character, method used transformation (used transformation TRUE). outlier Logical, whether outlier handling applied. plate_correction Logical, whether plate correction applied. centre_scale Logical, whether centering scaling applied.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/generate_labels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"generate labels — generate_labels","text":"list character labels indicating settings parameter.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/get_features_representatives_based_on_scores.html","id":null,"dir":"Reference","previous_headings":"","what":"Select representative features per cluster using correlation threshold and scores — get_features_representatives_based_on_scores","title":"Select representative features per cluster using correlation threshold and scores — get_features_representatives_based_on_scores","text":"function selects representative features pre-defined clusters variables, using correlation-based rule scoring vector:","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/get_features_representatives_based_on_scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select representative features per cluster using correlation threshold and scores — get_features_representatives_based_on_scores","text":"","code":"get_features_representatives_based_on_scores(   df,   cluster_feature_list,   corr_thresh,   scores )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/get_features_representatives_based_on_scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select representative features per cluster using correlation threshold and scores — get_features_representatives_based_on_scores","text":"df data frame containing feature columns referenced cluster_feature_list. Column names must match feature names. cluster_feature_list list element non-empty character vector feature names belonging one cluster (e.g., output prior clustering step). corr_thresh numeric threshold [0, 1]. two-feature clusters, |cor| >= corr_thresh, feature highest score selected. clusters two features, subclusters created cutting hierarchical tree h = 1 - corr_thresh. scores named numeric vector feature scores. features appearing cluster_feature_list must present names(scores).","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/get_features_representatives_based_on_scores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select representative features per cluster using correlation threshold and scores — get_features_representatives_based_on_scores","text":"list two components: representatives character vector selected representative features (one per single-feature cluster; zero, one, per multi-feature cluster, depending correlation structure threshold). representatives_map named list mapping representative feature (uniquely chosen) character vector features represents.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/get_features_representatives_based_on_scores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select representative features per cluster using correlation threshold and scores — get_features_representatives_based_on_scores","text":"cluster contains single feature, feature selected. cluster contains two features, absolute pairwise correlation computed. |cor| >= corr_thresh, highest-scoring feature selected; otherwise, features kept representatives. cluster contains two features, hierarchical clustering performed using distance 1 - |cor| method = \"average\". dendrogram cut h = 1 - corr_thresh form subclusters. subcluster, highest-scoring feature selected representative. cases unique representative chosen (sub)cluster, representatives_map stores mapping representative feature set original features represents. clusters size greater two, distance matrix computed 1 - abs(cor(X)) selected columns, followed hclust(..., method = \"average\"). Subclusters extracted via cutree(hc, h = 1 - corr_thresh). Within subcluster, representative feature maximum score. two-feature cluster |cor| < corr_thresh, features returned representatives mapping stored pair, neither represents design.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/get_features_representatives_based_on_scores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select representative features per cluster using correlation threshold and scores — get_features_representatives_based_on_scores","text":"","code":"# Toy data frame set.seed(1) df <- data.frame(   feat_a = rnorm(100),   feat_b = rnorm(100),   feat_c = rnorm(100),   feat_d = rnorm(100),   feat_e = rnorm(100),   feat_f = rnorm(100) )  # Example clusters cluster_feature_list <- list(   c(\"feat_a\", \"feat_b\", \"feat_c\"), # size > 2 -> hierarchical subclusters   \"feat_d\", # size = 1 -> itself   c(\"feat_e\", \"feat_f\") # size = 2 -> pairwise rule )  # Scores for all features scores <- c(   feat_a = 0.1,   feat_b = 0.4,   feat_c = 0.3,   feat_d = 0.9,   feat_e = 0.2,   feat_f = 0.8 )  # Choose a correlation threshold corr_thresh <- 0.7  res <- get_features_representatives_based_on_scores(   df = df,   cluster_feature_list = cluster_feature_list,   corr_thresh = corr_thresh,   scores = scores )  res$representatives #> [1] \"feat_a\" \"feat_b\" \"feat_c\" \"feat_d\" \"feat_e\" \"feat_f\" res$representatives_map #> list()"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/hybrid_imputation.html","id":null,"dir":"Reference","previous_headings":"","what":"Hybrid Imputation: Random Forest + LCMD — hybrid_imputation","title":"Hybrid Imputation: Random Forest + LCMD — hybrid_imputation","text":"function performs hybrid imputation selected columns data frame combining Random Forest (RF) imputation (via missForest) left-censored missing data (LCMD) imputation (via imputeLCMD). selects method per feature based --bag error (OOBE) RF model.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/hybrid_imputation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hybrid Imputation: Random Forest + LCMD — hybrid_imputation","text":"","code":"hybrid_imputation(   df,   target_cols = NULL,   is_qc = NULL,   method = c(\"RF-LCMD\"),   oobe_threshold = 0.1,   control_RF = list(),   control_LCMD = list() )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/hybrid_imputation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hybrid Imputation: Random Forest + LCMD — hybrid_imputation","text":"df data frame samples (rows) features (columns). target_cols character vector column names single regular expression identify target columns imputation. NULL, columns considered. is_qc logical vector indicating rows QC samples. Must match nrow(df). method Imputation strategy use (currently \"RF-LCMD\" supported). oobe_threshold Numeric. Features OOBE threshold use RF, others use LCMD. control_RF named list control arguments missForest::missForest(). Also supports n_cores (internal). control_LCMD named list control arguments imputeLCMD::impute.MAR.MNAR(), including mode = \"overall\" \"column-wise\".","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/hybrid_imputation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hybrid Imputation: Random Forest + LCMD — hybrid_imputation","text":"named list following components: hybrid_rf_lcmd fully imputed data frame combining RF LCMD decisions. rf RF-imputed data frame (non-QC rows , full column structure). lcmd LCMD-imputed data frame (non-QC rows , full column structure). oob named numeric vector feature-level OOB errors RF.","code":""},{"path":[]},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/impute_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute missing data in a data frame — impute_data","title":"Impute missing data in a data frame — impute_data","text":"function imputes missing data data frame (df) using specified imputation_method. Supported methods include \"LOD\", \"1/5th\", \"KNN\", \"PPCA\", \"median\", \"mean\", \"RF\", \"LCMD\".","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/impute_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute missing data in a data frame — impute_data","text":"","code":"impute_data(   df,   df_meta_features = NULL,   imputation_method = \"mean\",   col_features = NULL,   col_LOD = NULL )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/impute_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute missing data in a data frame — impute_data","text":"df data frame missing values imputed. df_meta_features data frame containing feature metadata, required \"LOD\" imputation. imputation_method character string specifying imputation method. Valid options : \"LOD\", \"1/5th\", \"KNN\", \"PPCA\", \"median\", \"mean\", \"RF\", \"LCMD\". col_features (Optional) Character name column df_meta_features containing feature names, required \"LOD\" imputation. col_LOD (Optional) Character name column df_meta_features containing limit detection (LOD) values, required \"LOD\" imputation.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/impute_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute missing data in a data frame — impute_data","text":"data frame (df) imputed values.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/impute_with_half_min.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute Missing Values with Half the Minimum — impute_with_half_min","title":"Impute Missing Values with Half the Minimum — impute_with_half_min","text":"function imputes missing values numeric columns replacing NA half minimum non-missing value column. can restrict imputation subset columns using cols argument.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/impute_with_half_min.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute Missing Values with Half the Minimum — impute_with_half_min","text":"","code":"impute_with_half_min(df, cols = NULL)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/impute_with_half_min.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute Missing Values with Half the Minimum — impute_with_half_min","text":"df data frame containing numeric columns impute. cols Optional. character vector column names impute. NULL, numeric columns imputed.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/impute_with_half_min.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute Missing Values with Half the Minimum — impute_with_half_min","text":"data frame missing values imputed specified (numeric) columns.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/impute_with_half_min.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Impute Missing Values with Half the Minimum — impute_with_half_min","text":"","code":"if (FALSE) { # \\dontrun{ impute_with_half_min(df) # Impute all numeric columns impute_with_half_min(df, cols = c(\"a\", \"b\")) # Impute only columns a and b } # }"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/normalise_SERRF.html","id":null,"dir":"Reference","previous_headings":"","what":"SERRF Normalization — normalise_SERRF","title":"SERRF Normalization — normalise_SERRF","text":"Applies SERRF normalization method remove unwanted variation (Fan 2019, Anal Chem).","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/normalise_SERRF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SERRF Normalization — normalise_SERRF","text":"","code":"normalise_SERRF(   df,   target_cols = NULL,   is_qc = NULL,   strata_col = NULL,   num_screen_SERRF = 10 )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/normalise_SERRF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SERRF Normalization — normalise_SERRF","text":"df data frame tibble. target_cols Feature columns normalize (character vector selector passed resolve_target_cols). is_qc Logical vector indicating rows QC samples. Must length number rows df. strata_col Name column containing batch/strata IDs. NULL, dummy single-level strata created samples treated one batch. provided, column must exist df NA values. num_screen_SERRF Number correlated features use model fitting. Default 10.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/normalise_SERRF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SERRF Normalization — normalise_SERRF","text":"normalized data frame.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/normalization_residualMixedModels.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize feature Data Using Residual Mixed Models — normalization_residualMixedModels","title":"Normalize feature Data Using Residual Mixed Models — normalization_residualMixedModels","text":"function normalizes feature data removing unwanted effects using mixed models. accounts random effects fixed effects specified user, optionally corrects heteroskedasticity. Residuals calculated FUNnormalization_residualMixedModels(). method details https://www.mdpi.com/2218-1989/11/9/631","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/normalization_residualMixedModels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize feature Data Using Residual Mixed Models — normalization_residualMixedModels","text":"","code":"normalization_residualMixedModels(   list,   identifier = c(\"ID_sample\"),   listRandom = NULL,   listFixedToKeep = NULL,   listFixedToRemove = NULL,   HeteroSked = NULL )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/normalization_residualMixedModels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize feature Data Using Residual Mixed Models — normalization_residualMixedModels","text":"list list containing following elements: data_features data frame tibble dimensions n x (K+p) : n Number observations. p Number features. K Number variables used unique identification individuals. data_samples data frame tibble dimensions n x (K+d) : n Number observations. K Number unique identifiers. d Additional variables useful final analysis (e.g., country, age, BMI). data_meta_features p x 3 matrix indicating feature's Name, Class, Type. identifier character vector strings indicating names variables used unique identification individuals. listRandom character vector strings containing variable names modeled random effects removed. NULL, either length 1 contain nested variables. listFixedToKeep character vector strings containing variable names modeled fixed effects kept. listFixedToRemove character vector strings containing variable names modeled fixed effects removed. HeteroSked string NULL. NULL, name variable heteroskedasticity accounted . Must included listRandom.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/normalization_residualMixedModels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalize feature Data Using Residual Mixed Models — normalization_residualMixedModels","text":"list : data tibble unwanted variation removed. data_samples input 'data_samples' data frame, ordered IdentifierPipeline. data_meta_features input 'data_meta_features' matrix.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/outlier_pca_lof.html","id":null,"dir":"Reference","previous_headings":"","what":"PCA-Based Outlier Detection Using LOF — outlier_pca_lof","title":"PCA-Based Outlier Detection Using LOF — outlier_pca_lof","text":"Performs Principal Component Analysis (PCA) data frame identifies sample outliers using Local Outlier Factor (LOF) method. Optionally returns ggplot2 pair plot PCA scores coloured LOF. Samples detected outliers removed returned data.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/outlier_pca_lof.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PCA-Based Outlier Detection Using LOF — outlier_pca_lof","text":"","code":"outlier_pca_lof(df, return_ggplot = TRUE, verbose = TRUE)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/outlier_pca_lof.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PCA-Based Outlier Detection Using LOF — outlier_pca_lof","text":"df data frame samples rows features columns. Must contain missing values. return_ggplot Logical; TRUE, returns ggplot2 pair plot highlighting outliers. verbose Logical; TRUE, prints progress messages.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/outlier_pca_lof.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PCA-Based Outlier Detection Using LOF — outlier_pca_lof","text":"list following elements: df Filtered data frame outliers removed. missing values present, original input returned unchanged. plot_samples_outlier ggplot2 object showing PCA LOF scores, NULL return_ggplot = FALSE missing values found. id_samples_outlier character vector sample IDs (rownames) identified outliers, NULL skipped.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/outlier_pca_lof.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PCA-Based Outlier Detection Using LOF — outlier_pca_lof","text":"","code":"if (FALSE) { # \\dontrun{ result <- outlier_pca_lof(df = my_data) head(result$df) print(result$plot_samples_outlier) result$id_samples_outlier } # }"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/parse_mass_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse mass/retention-time strings — parse_mass_rt","title":"Parse mass/retention-time strings — parse_mass_rt","text":"Extract mass retention time (RT) values strings form \"mass@rt\". Accepts single string vector.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/parse_mass_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse mass/retention-time strings — parse_mass_rt","text":"","code":"parse_mass_rt(x, what = c(\"mass\", \"rt\", \"both\"), clean_rt_suffix = TRUE)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/parse_mass_rt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse mass/retention-time strings — parse_mass_rt","text":"x Character vector entries like \"123.4@56.7\" , clean_rt_suffix = TRUE, possibly \"123.4@56.7:1\". values return: \"mass\", \"rt\", \"\". clean_rt_suffix Logical. TRUE, removes suffixes \":1\" \":2\" RT part.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/parse_mass_rt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse mass/retention-time strings — parse_mass_rt","text":"Numeric vector (\"mass\" \"rt\") data.frame two columns (\"\").","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/parse_mass_rt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse mass/retention-time strings — parse_mass_rt","text":"","code":"parse_mass_rt(\"100.5@23.1\", what = \"mass\") #> [1] 100.5 parse_mass_rt(c(\"10.2@1.5\", \"20.4@2.5\"), what = \"rt\") #> [1] 1.5 2.5 parse_mass_rt(\"50@7.5\", what = \"both\") #>   mass  rt #> 1   50 7.5  parse_mass_rt(\"100.5@23.1:1\",   what = \"rt\",   clean_rt_suffix = TRUE ) #> [1] 23.1"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/process_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Process feature data — process_data","title":"Process feature data — process_data","text":"function processes feature data given specified metadata. supports exclusion features extreme missingness, various imputation methods, transformation, plate correction, centering, case-control data handling.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/process_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process feature data — process_data","text":"","code":"process_data(   data,   data_meta_features = NULL,   data_meta_samples = NULL,   col_samples,   col_features = NULL,   save = FALSE,   path_out = NULL,   path_outliers = NULL,   exclusion_extreme_feature = FALSE,   missing_pct_feature = NULL,   exclusion_extreme_sample = FALSE,   missing_pct_sample = NULL,   imputation = FALSE,   imputation_method = NULL,   col_LOD = NULL,   transformation = FALSE,   transformation_method = NULL,   outlier = FALSE,   plate_correction = FALSE,   cols_listRandom = NULL,   cols_listFixedToKeep = NULL,   cols_listFixedToRemove = NULL,   col_HeteroSked = NULL,   centre_scale = FALSE,   case_control = FALSE,   col_case_control = NULL )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/process_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process feature data — process_data","text":"data data frame first column sample IDs remaining columns containing feature values, feature IDs column names. data_meta_features data frame containing metadata features, including information limit detection missingness percentage. data_meta_samples data frame containing metadata samples, including information necessary plate correction case-control analysis. col_samples string specifying column name data contains sample IDs (e.g., \"Idepic_Bio\"). col_features string specifying column name data_meta_features contains feature IDs, match column names data (e.g., \"UNIPROT\"). save logical whether want save feature data, plots, exclusion info. Default FALSE/. path_out string specifying output directory processed data saved. path_outliers string specifying output directory outlier information saved. exclusion_extreme_feature logical flag indicating whether exclude features extreme missingness. Default FALSE. missing_pct_feature numeric value specifying threshold percentage missingness features excluded (e.g., 0.9). exclusion_extreme_sample logical flag indicating whether exclude samples extreme missingness. Default FALSE. missing_pct_sample numeric value specifying threshold percentage missingness samples excluded (e.g., 0.9). imputation logical flag indicating whether imputation performed. Default FALSE. imputation_method string specifying method use imputation. Options include \"LOD\", \"1/5th\", \"KNN\", \"PPCA\", \"median\", \"mean\", \"RF\", \"LCMD\". col_LOD string specifying column name data_meta_features contains limit detection (LOD) values, required imputation_method \"LOD\". transformation logical flag indicating whether transformation performed. Default FALSE. transformation_method string specifying method use transformation. Options include \"InvRank\", \"Log10\", \"Log10Capped\", \"Log10ExclExtremes\". outlier logical flag indicating whether outlier exclusion performed across features samples. Default FALSE. plate_correction logical flag indicating whether plate correction performed. Default FALSE. cols_listRandom string vector specifying columns data_meta_samples treated random effects plate correction (e.g., \"batch_plate\"). cols_listFixedToKeep vector specifying columns data_meta_samples treated fixed effects plate correction retained model (e.g., c(\"Center\", \"Country\")). cols_listFixedToRemove vector specifying columns data_meta_samples treated fixed effects plate correction removed model. Default NULL. col_HeteroSked string specifying column data_meta_samples used heteroskedasticity correction. centre_scale logical flag indicating whether center scale data. Default FALSE. case_control logical flag indicating whether data case-control matched samples handled accordingly. Default FALSE. col_case_control string specifying column name data_meta_samples contains case-control matching information (e.g., \"Match_Caseset\").","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/process_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process feature data — process_data","text":"processed data returned saved .rds file specified output directory.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/process_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Process feature data — process_data","text":"function performs several data processing steps (order): Excludes features extreme missingness based specified threshold. Excludes samples extreme missingness based specified threshold. Imputes missing values using various methods. Transforms data using specified methods. Excludes outlying samples using PCA LOF. Handles case-control data ensure matched samples treated appropriately. Corrects plate effects using specified random fixed effects. Centers scales data centre_scale TRUE.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/register_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Register a parallel cluster for parallel processing. — register_cluster","title":"Register a parallel cluster for parallel processing. — register_cluster","text":"function creates registers parallel cluster parallel processing R.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/register_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register a parallel cluster for parallel processing. — register_cluster","text":"","code":"register_cluster(num_cores)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/register_cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register a parallel cluster for parallel processing. — register_cluster","text":"num_cores number CPU cores used parallel cluster.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/register_cluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Register a parallel cluster for parallel processing. — register_cluster","text":"parallel cluster object registered parallel processing.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/register_cluster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Register a parallel cluster for parallel processing. — register_cluster","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage: cluster <- register_cluster(4) # Use the registered cluster for parallel processing } # }"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/remove_outliers.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove outliers (optionally stratified) using PCA + LOF — remove_outliers","title":"Remove outliers (optionally stratified) using PCA + LOF — remove_outliers","text":"Wrapper around outlier_pca_lof() conveniences: Select subset columns (target_cols) Exclude QC rows outlier detection Temporarily impute missing values (half column minimum) detection Apply detection independently within user-defined strata (strata)","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/remove_outliers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove outliers (optionally stratified) using PCA + LOF — remove_outliers","text":"","code":"remove_outliers(   df,   target_cols = NULL,   is_qc = NULL,   method = c(\"pca-lof-overall\"),   impute_method = c(NULL, \"half-min-value\"),   restore_missing_values = TRUE,   return_ggplots = FALSE,   strata = NULL )"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/remove_outliers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove outliers (optionally stratified) using PCA + LOF — remove_outliers","text":"df data.frame features columns samples rows. target_cols Character vector column names (tidyselect helpers supported resolve_target_cols()). NULL, uses resolve_target_cols(df, NULL) infer targets. is_qc Logical vector (length nrow(df)) marking QC rows exclude detection. Defaults FALSE. method Character; currently supports \"pca-lof-overall\" (default behavior). impute_method NULL \"half-min-value\". set, missing values target_cols imputed half minimum non-missing value—default within stratum; #'   stratum target column entirely NA, imputation performed globally non-QC rows (see Missing-data policy). restore_missing_values Logical; TRUE, original NAs target_cols restored filtering. return_ggplots Logical; TRUE, returns named list ggplots per stratum. strata NULL (default), single column name df, external vector length nrow(df). provided, outlier detection run independently within stratum (QC rows excluded within stratum).","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/remove_outliers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove outliers (optionally stratified) using PCA + LOF — remove_outliers","text":"list : df_filtered df detected outlier rows removed (QC rows always retained). excluded_ids Character vector row names removed (union across strata). plot_samples_outlier return_ggplots = TRUE, named list ggplot objects per stratum; otherwise NULL.","code":""},{"path":[]},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/remove_outliers.html","id":"stratification","dir":"Reference","previous_headings":"","what":"Stratification","title":"Remove outliers (optionally stratified) using PCA + LOF — remove_outliers","text":"Set strata : NULL (default) run detection non-QC rows, single column name df, external vector (length nrow(df)) group samples. Outlier detection performed independently within stratum non-QC rows (QC rows always excluded detection retained output). Strata fewer 5 non-QC samples skipped (outliers removed stratum).","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/remove_outliers.html","id":"missing-data-policy","dir":"Reference","previous_headings":"","what":"Missing-data policy","title":"Remove outliers (optionally stratified) using PCA + LOF — remove_outliers","text":"impute_method = NULL target_cols contain missing values among non-QC rows, function errors lists affected columns counts. Enable impute_method = \"half-min-value\" resolve missingness beforehand. impute_method = \"half-min-value\": function first checks target columns entirely NA across non-QC rows. exist, errors (half-minimum computed). checks, per stratum, target columns entirely NA within stratum. found, warning emitted listing affected strata columns, temporary imputation applied whole non-QC dataset (ignoring stratification), outlier detection still runs per stratum requested. outlier removal, restore_missing_values = TRUE, original NAs target_cols restored returned data.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/remove_outliers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove outliers (optionally stratified) using PCA + LOF — remove_outliers","text":"","code":"# 1) No stratification remove_outliers(   df,   target_cols = c(\"f1\",\"f2\"),   impute_method = \"half-min-value\" ) #> Error in rep(FALSE, nrow(df)): invalid 'times' argument  # 2) Stratify by a column in df remove_outliers(   df,   target_cols = c(\"f1\",\"f2\"),   strata = \"batch\",   impute_method = \"half-min-value\" ) #> Error in rep(FALSE, nrow(df)): invalid 'times' argument  # 3) Stratify by an external vector my_strata <- c(\"A\", \"A\", \"B\", \"B\", \"B\", \"C\", \"C\") remove_outliers(   df,   target_cols = c(\"f1\",\"f2\"),   strata = grp,   impute_method = \"half-min-value\" ) #> Error in rep(FALSE, nrow(df)): invalid 'times' argument  # 4) Stratum with all-NA target columns -> triggers global temporary imputation (warning) # \\donttest{ df2 <- data.frame(   f1 = c(1, 2, 3, NA, NA, NA),   f2 = c(2, 3, 4, NA, NA, NA),   batch = c(\"A\",\"A\",\"A\",\"B\",\"B\",\"B\") ) rownames(df2) <- paste0(\"s\", seq_len(nrow(df2))) remove_outliers(   df2,   target_cols = c(\"f1\",\"f2\"),   strata = \"batch\",   impute_method = \"half-min-value\" ) #> Warning:  #>  #> Detected strata with columns entirely missing among non-QC rows. Applying temporary imputation on the whole non-QC dataset (ignoring stratification). Affected strata and columns: #> strat : columns #>   - B: f1, f2 #> $df_filtered #>    f1 f2 batch #> s1  1  2     A #> s2  2  3     A #> s3  3  4     A #> s4 NA NA     B #> s5 NA NA     B #> s6 NA NA     B #>  #> $plot_samples_outlier #> NULL #>  #> $excluded_ids #> character(0) #>  # }"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/resolve_target_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Resolve Target Columns from Names or Regex — resolve_target_cols","title":"Resolve Target Columns from Names or Regex — resolve_target_cols","text":"utility function determines columns data frame selected downstream operations based user-supplied specification. specification can :","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/resolve_target_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resolve Target Columns from Names or Regex — resolve_target_cols","text":"","code":"resolve_target_cols(df, target_cols)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/resolve_target_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resolve Target Columns from Names or Regex — resolve_target_cols","text":"df data frame columns selected. target_cols character vector column names single regular expression string.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/resolve_target_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resolve Target Columns from Names or Regex — resolve_target_cols","text":"character vector resolved column names present df.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/resolve_target_cols.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Resolve Target Columns from Names or Regex — resolve_target_cols","text":"NULL: Selects columns. character vector column names: Selects columns explicitly. single string regular expression: Selects matching column names.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/resolve_target_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Resolve Target Columns from Names or Regex — resolve_target_cols","text":"","code":"df <- data.frame(a = 1, b = 2, c_score = 3) resolve_target_cols(df, NULL)         # returns all columns #> [1] \"a\"       \"b\"       \"c_score\" resolve_target_cols(df, \"c_\")         # regex match (returns \"c_score\") #> [1] \"c_score\" resolve_target_cols(df, c(\"a\", \"b\"))  # exact names #> [1] \"a\" \"b\""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/rows_keep_from_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Select rows to keep based on missingness — rows_keep_from_cols","title":"Select rows to keep based on missingness — rows_keep_from_cols","text":"Computes per-row NA proportions across provided target columns. QC rows (is_qc_full == TRUE) always retained.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/rows_keep_from_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select rows to keep based on missingness — rows_keep_from_cols","text":"","code":"rows_keep_from_cols(df, cols_target, row_thresh, is_qc_full)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/rows_keep_from_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select rows to keep based on missingness — rows_keep_from_cols","text":"df data.frame. cols_target Character vector target column names (subset names(df)). row_thresh Numeric. Maximum allowed proportion missing values per row. is_qc_full Logical vector length nrow(df); TRUE QC rows.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/rows_keep_from_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select rows to keep based on missingness — rows_keep_from_cols","text":"Integer indices rows keep.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/run_lcmd_imputation.html","id":null,"dir":"Reference","previous_headings":"","what":"Run LCMD Imputation (Overall) — run_lcmd_imputation","title":"Run LCMD Imputation (Overall) — run_lcmd_imputation","text":"Performs left-censored missing data (LCMD) imputation using imputeLCMD::impute.MAR.MNAR() overall mode.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/run_lcmd_imputation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run LCMD Imputation (Overall) — run_lcmd_imputation","text":"","code":"run_lcmd_imputation(df, target_cols, control_LCMD = list())"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/run_lcmd_imputation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run LCMD Imputation (Overall) — run_lcmd_imputation","text":"df data frame containing data impute. target_cols character vector column names imputed. control_LCMD named list optional arguments: method.MAR Method MAR imputation (e.g., \"KNN\"). method.MNAR Method MNAR imputation (e.g., \"QRILC\", \"MinProb\").","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/run_lcmd_imputation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run LCMD Imputation (Overall) — run_lcmd_imputation","text":"data frame shape order input, imputed values.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/run_rf_imputation.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Random Forest Imputation with Optional Parallelization — run_rf_imputation","title":"Run Random Forest Imputation with Optional Parallelization — run_rf_imputation","text":"function performs missing value imputation using missForest package subset columns data frame. Column selection can explicit based regular expression, using resolve_target_cols internally.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/run_rf_imputation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Random Forest Imputation with Optional Parallelization — run_rf_imputation","text":"","code":"run_rf_imputation(df, target_cols, control_RF = list())"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/run_rf_imputation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Random Forest Imputation with Optional Parallelization — run_rf_imputation","text":"df data frame containing data imputed. non-QC rows passed . target_cols character vector column names regex string identify columns impute. control_RF named list additional overriding arguments passed missForest::missForest(). Also supports internal control argument n_cores (numeric), used determine parallelism parallelize \"\". Accepted entries include (see missForest::missForest details): mtry Number variables randomly sampled split. ntree Number trees grow. maxiter Maximum number imputation iterations. parallelize Character string: \"\", \"variables\", \"forests\". Enables parallelization. variablewise Logical. TRUE, variable-wise error returned. verbose Logical. TRUE, progress messages printed. replace Logical. Whether sampling observations done replacement. classwt, cutoff, strata, sampsize, etc. optional arguments passed randomForest::randomForest. n_cores (Internal) Number CPU cores use parallelize \"\". removed calling missForest().","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/run_rf_imputation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Random Forest Imputation with Optional Parallelization — run_rf_imputation","text":"list two components: imputed data frame shape input subset, imputed values. oob named numeric vector --bag error estimates feature (available).","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/run_rf_imputation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run Random Forest Imputation with Optional Parallelization — run_rf_imputation","text":"function supports optional parallel execution via missForest's parallelize argument. n_cores less equal 1, parallelization disabled automatically imputation runs sequentially.","code":""},{"path":[]},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/run_rf_imputation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Random Forest Imputation with Optional Parallelization — run_rf_imputation","text":"","code":"if (FALSE) { # \\dontrun{ df <- data.frame(a = c(1, NA, 3), b = c(4, 5, NA))  # Default imputation on selected columns run_rf_imputation(df, target_cols = c(\"a\", \"b\"))  # Use regex to select columns and customize RF parameters run_rf_imputation(     df,     target_cols = \"^a|b$\",     control_RF = list(ntree = 200, mtry = 1, n_cores = 4) ) } # }"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/transform_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Data Transformation to Data Frame — transform_data","title":"Apply Data Transformation to Data Frame — transform_data","text":"function applies various data transformations numeric data frame based specified transformation method. Supported methods include \"InvRank\", \"Log10\", \"Log10Capped\", \"Log10ExclExtremes\".","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/transform_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Data Transformation to Data Frame — transform_data","text":"","code":"transform_data(df, transformation_method)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/transform_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Data Transformation to Data Frame — transform_data","text":"df data frame containing numeric data transformation. transformation_method string specifying transformation method apply. Supported values \"InvRank\", \"Log10\", \"Log10Capped\", \"Log10ExclExtremes\".","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/transform_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Data Transformation to Data Frame — transform_data","text":"list containing: df transformed data frame applied method. transformation_method label applied transformation method. centre_scale label indicating whether data centered scaled (TRUE NA). conditions met specified transformation method, original data frame returned list.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/unregister_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Unregister a parallel cluster used for parallel processing. — unregister_cluster","title":"Unregister a parallel cluster used for parallel processing. — unregister_cluster","text":"function unregisters previously registered parallel cluster used parallel processing R.","code":""},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/unregister_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unregister a parallel cluster used for parallel processing. — unregister_cluster","text":"","code":"unregister_cluster(cluster = NULL)"},{"path":"https://iarcbiostat.github.io/OmicsProcessing/reference/unregister_cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unregister a parallel cluster used for parallel processing. — unregister_cluster","text":"cluster parallel cluster object unregistered (default NULL).","code":""}]
