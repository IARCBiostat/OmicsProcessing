% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/feature_clustering.R
\name{cluster_features_by_retention_time}
\alias{cluster_features_by_retention_time}
\title{Cluster features by retention time and summarise within clusters}
\usage{
cluster_features_by_retention_time(
  df,
  target_cols = NULL,
  is_qc = NULL,
  rt_height = 0.07,
  method = c("correlations", "scores"),
  scores = NULL,
  cut_height = NULL,
  corr_thresh = NULL
)
}
\arguments{
\item{df}{A data.frame (or tibble) with feature data in columns and samples in
rows.}

\item{target_cols}{Character vector of feature/column names to use. If \code{NULL},
\code{\link[=resolve_target_cols]{resolve_target_cols()}} is used to determine the set of features.}

\item{is_qc}{Logical vector marking QC samples. Must have length equal to
\code{nrow(df)}. If \code{NULL}, all samples are treated as non-QC.
(Currently only used for consistency with other interfaces; it is not
used directly in this function.)}

\item{rt_height}{Numeric height at which to cut the dendrogram in retention-time
space. Smaller values create more clusters.}

\item{method}{Character string indicating how to obtain a single representative per
retention-time cluster. Either \code{"correlations"} or \code{"scores"}.
With \code{"scores"}, one existing feature per cluster is selected based
on pre-computed scores. With \code{"correlations"}, clusters are further
processed using correlation-based summarisation.}

\item{scores}{Named numeric vector of feature scores, required when
\code{method = "scores"}. Names must coincide with \code{target_cols}.
For each retention-time cluster, the feature with the largest score is
chosen as representative.}

\item{cut_height}{Numeric height used inside \code{cluster_features_based_on_correlations}
when \code{method = "correlations"}. Passed on to that function's
\code{cut_height} argument.}

\item{corr_thresh}{Numeric threshold used inside \code{cluster_features_based_on_correlations}
when \code{method = "correlations"}. Passed on to that function's
\code{corr_thresh} argument.}
}
\value{
A list with two elements:

\describe{
\item{\code{clustered_df}}{
A data.frame with one column per final representative feature.
When \code{method = "scores"}, this consists of a subset of the
original feature columns. When \code{method = "correlations"}, it
may contain synthetic features created by
\code{cluster_features_based_on_correlations()}.
}
\item{\code{representatives_map}}{
A named list mapping each representative feature (original or
synthetic) to the character vector of feature names that it
represents within its retention-time cluster.
}
}
}
\description{
Groups features into clusters based on their retention time using
hierarchical clustering, then selects a representative feature for each
cluster either via scores or via correlation-based aggregation.
}
\details{
The function proceeds in two steps:

\enumerate{
\item Retention-time clustering: feature names in \code{target_cols}
are first parsed using \code{\link[=parse_mass_rt]{parse_mass_rt()}} to extract retention times,
which are then clustered by \code{cluster_hierarchical()} at height
\code{rt_height}. This yields groups of features with similar
retention times.
\item Within-cluster summarisation:
\itemize{
\item If \code{method = "scores"}, each retention-time cluster is
reduced to a single original feature using
\code{get_features_representatives_based_on_scores()}, based on
the supplied \code{scores}.
\item If \code{method = "correlations"}, each retention-time
cluster is passed as a feature list to
\code{cluster_features_based_on_correlations()}, which may
further split or summarise the cluster into synthetic variables
based on correlations.
}
}
}
\examples{
\dontrun{
df <- data.frame(
  `100@150` = rnorm(20),
  `100@151` = rnorm(20),
  `101@200` = rnorm(20)
)

target_cols <- c("100@150", "100@151", "101@200")
is_qc <- rep(FALSE, nrow(df))

## Using scores to pick one feature per RT cluster
scores <- c(
  `100@150` = 0.2,
  `100@151` = 0.8,
  `101@200` = 0.5
)

res_scores <- cluster_features_by_retention_time(
  df = df,
  target_cols = target_cols,
  is_qc = is_qc,
  rt_height = 0.07,
  method = "scores",
  scores = scores
)

## Using correlation-based summarisation within RT clusters
res_corr <- cluster_features_by_retention_time(
  df = df,
  target_cols = target_cols,
  is_qc = is_qc,
  rt_height = 0.07,
  method = "correlations",
  cut_height = 0.26,
  corr_thresh = 0.75
)
}

}
\seealso{
\code{\link{resolve_target_cols}},
\code{\link{parse_mass_rt}},
\code{\link{cluster_hierarchical}},
\code{\link{get_features_representatives_based_on_scores}},
\code{\link{cluster_features_based_on_correlations}}
}
