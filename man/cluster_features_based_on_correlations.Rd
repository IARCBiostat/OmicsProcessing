% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/feature_clustering.R
\name{cluster_features_based_on_correlations}
\alias{cluster_features_based_on_correlations}
\title{Cluster feature groups based on correlations}
\usage{
cluster_features_based_on_correlations(
  df,
  cluster_feature_list,
  cut_height,
  corr_thresh
)
}
\arguments{
\item{df}{A tibble or data.frame containing the feature columns (and
possibly other variables not used here). All variables referenced in
\code{cluster_feature_list} must be columns of \code{df}.}

\item{cluster_feature_list}{A list where each element is a character vector
giving the names of the features that belong to one initial cluster.
Feature names are typically of the form \code{"RT@mass"}, where
\code{RT} and \code{mass} are real numbers corresponding to retention
time and mass, but any valid column names are accepted.}

\item{cut_height}{Numeric. Cut-off height for the correlation-based
clustering within groups of size three or more (as implemented in
\pkg{ClustOfVar}). A suggested value is \code{0.26}, which corresponds
roughly to a pairwise correlation of about \code{0.75}. You can use a
dedicated helper (e.g. \code{simul_eval_link_hhh_corr}) to explore the
correspondence between pairwise correlations and the tree height returned
by \code{ClustOfVar::hclustvar()}.}

\item{corr_thresh}{Numeric. Cut-off for the absolute pairwise correlation
used when the number of features in a group is exactly two. If the
absolute correlation between the two features is at least
\code{corr_thresh}, they are replaced by a single synthetic feature
(first principal component); otherwise both original features are kept.}
}
\value{
A list with the following components:
\describe{
\item{clustered_df}{A tibble with one row per observation and one column
per final representative feature. For clusters of size one, the column
is the original feature. For size two with correlation above
\code{corr_thresh}, the column is the first principal component of
the two features. For larger clusters, columns are synthetic variables
returned by \pkg{ClustOfVar}, oriented to have a positive correlation
with the first feature of the corresponding sub-cluster.}
\item{representatives_map}{A named list mapping each synthetic feature
(columns whose names start with \code{"SynthFeat@"}) to the character
vector of original feature names that it summarises. Original features
that are kept as is do not appear in this map.}
}
}
\description{
Given a list of pre-defined feature groups, construct a data set of
representative features by collapsing groups with high correlations into
synthetic variables.
}
\details{
For groups of size one, the original feature is kept as is. For groups of
size two, the decision is based on their pairwise correlation. For larger
groups, clustering is based on the decrease in homogeneity as in the
\pkg{ClustOfVar} package. The homogeneity of a cluster is the squared
correlation (for quantitative variables) between the variables and the
cluster centre (the first principal component).

This function is typically used after a pre-grouping step (for example,
after retention-time-based grouping). Each element of
\code{cluster_feature_list} corresponds to one such pre-defined group and
may contain one, two, or more feature names; all cases are handled.

For groups of size three or more, a hierarchical clustering tree is first
obtained using \code{ClustOfVar::hclustvar()}. The tree is then cut at
a data-driven position derived from \code{cut_height}, and
\code{ClustOfVar::cutreevar()} is used to obtain synthetic scores for the
resulting sub-clusters. Each score is multiplied by \eqn{+1} or \eqn{-1}
so that it has a positive correlation with the first feature in its
sub-cluster.
}
\examples{
set.seed(123)
data_tbl <- tibble::tibble(
  `100@150` = rnorm(20),
  `100@151` = rnorm(20),
  `101@200` = rnorm(20)
)

# Pre-defined feature groups (e.g. after a retention-time grouping step)
cluster_feature_list <- list(
  c("100@150", "100@151"), # group of size 2
  "101@200" # group of size 1
)

res <- cluster_features_based_on_correlations(
  df = data_tbl,
  cluster_feature_list = cluster_feature_list,
  cut_height = 0.26,
  corr_thresh = 0.75
)

res$clustered_df
res$representatives_map

}
